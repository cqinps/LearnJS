# 标准库之包装对象

对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”（wrapper）。 

```js
var v1 = new Number(123);
var v2 = new String('abc');
var v3 = new Boolean(true);

typeof v1 // "object"
typeof v2 // "object"
typeof v3 // "object"

v1 === 123 // false
v2 === 'abc' // false
v3 === true // false
```

 `Number`、`String`和`Boolean`这三个原生对象，如果不作为构造函数调用（即调用时不加`new`），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值。 

```js
// 字符串转为数值
Number('123') // 123

// 数值转为字符串
String(123) // "123"

// 数值转为布尔值
Boolean(123) // true
```

## 实例方法

 三种包装对象各自提供了许多实例方法，  这里介绍两种它们共同具有、从`Object`对象继承的方法：`valueOf()`和`toString()`。 

+  `valueOf()`方法返回包装对象实例对应的原始类型的值。 

+  `toString()`方法返回对应的字符串形式。 

## 原始类型与实例对象的自动转换

 某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。 

 比如，字符串可以调用`length`属性，返回字符串的长度。 

```js
'abc'.length // 3
```

上面代码中，`abc`是一个字符串，本身不是对象，不能调用`length`属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用`length`属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。 

```js
var str = 'abc';
str.length // 3

// 等同于
var strObj = new String(str)
// String {
//   0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"
// }
strObj.length // 3
```

 上面代码中，字符串`abc`的包装对象提供了多个属性，`length`只是其中之一。 

 自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。 

```js
var s = 'Hello World';
s.x = 123;
s.x // undefined
```

 上面代码为字符串`s`添加了一个`x`属性，结果无效，总是返回`undefined`。 

 另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象`String.prototype`上 

## 自定义方法

除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。

比如，我们可以新增一个`double`方法，使得字符串和数字翻倍。

```js
String.prototype.double = function () {
  return this.valueOf() + this.valueOf();
};

'abc'.double()
// abcabc

Number.prototype.double = function () {
  return this.valueOf() + this.valueOf();
};

(123).double() // 246
```

 上面代码在`String`和`Number`这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后一行的`123`外面必须要加上圆括号，否则后面的点运算符（`.`）会被解释成小数点。 

# Boolean 对象

 `Boolean`对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。 

```
var b = new Boolean(true);

typeof b // "object"
b.valueOf() // true
```

上面代码的变量`b`是一个`Boolean`对象的实例，它的类型是对象，值为布尔值`true`。

**注意，`false`对应的包装对象实例，布尔运算结果也是`true`。**

```js
if (new Boolean(false)) {
  console.log('true');
} // true

if (new Boolean(false).valueOf()) {
  console.log('true');
} // 无输出
```

 上面代码的第一个例子之所以得到`true`，是因为`false`对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值`true`（因为所有对象对应的布尔值都是`true`）。而实例的`valueOf`方法，则返回实例对应的原始值，本例为`false`。 

+ ## Boolean 函数的类型转换作用

 `Boolean`对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时`Boolean`就是一个单纯的工具方法。 

```js
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean('') // false
Boolean(NaN) // false

Boolean(1) // true
Boolean('false') // true
Boolean([]) // true
Boolean({}) // true
Boolean(function () {}) // true
Boolean(/foo/) // true
```

**顺便提一下，使用双重的否运算符（`!`）也可以将任意值转为对应的布尔值。** 

最后，对于一些特殊值，`Boolean`对象前面加不加`new`，会得到完全相反的结果，必须小心。 

```js
if (Boolean(false)) {
  console.log('true');
} // 无输出

if (new Boolean(false)) {
  console.log('true');
} // true

if (Boolean(null)) {
  console.log('true');
} // 无输出

if (new Boolean(null)) {
  console.log('true');
} // true
```

# Number 对象

 `Number`对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。 

 作为构造函数时，它用于生成值为数值的对象。 

```js
var n = new Number(1);
typeof n // "object"
```

上面代码中，`Number`对象作为构造函数使用，返回一个值为`1`的对象。 

 作为工具函数时，它可以将任何类型的值转为数值。 

```js
Number(true) // 1
```

## 静态属性

`Number`对象拥有以下一些静态属性（即直接定义在`Number`对象上的属性，而不是定义在实例上的属性）。

- `Number.POSITIVE_INFINITY`：正的无限，指向`Infinity`。
- `Number.NEGATIVE_INFINITY`：负的无限，指向`-Infinity`。
- `Number.NaN`：表示非数值，指向`NaN`。
- `Number.MIN_VALUE`：表示最小的正数（即最接近0的正数，在64位浮点数体系中为`5e-324`），相应的，最接近0的负数为`-Number.MIN_VALUE`。
- `Number.MAX_SAFE_INTEGER`：表示能够精确表示的最大整数，即`9007199254740991`。
- `Number.MIN_SAFE_INTEGER`：表示能够精确表示的最小整数，即`-9007199254740991`。

```js
Number.POSITIVE_INFINITY // Infinity
Number.NEGATIVE_INFINITY // -Infinity
Number.NaN // NaN

Number.MAX_VALUE
// 1.7976931348623157e+308
Number.MAX_VALUE < Infinity
// true

Number.MIN_VALUE
// 5e-324
Number.MIN_VALUE > 0
// true

Number.MAX_SAFE_INTEGER // 9007199254740991
Number.MIN_SAFE_INTEGER // -9007199254740991
```

## 实例方法

 `Number`对象有4个实例方法，都跟将数值转换成指定格式有关。 

+  `Number`对象部署了自己的`toString`方法，用来将一个数值转为字符串形式。 

  ```js
  (10).toString() // "10"
  ```

  ```js
  (10).toString(2) // "1010"
  (10).toString(8) // "12"
  (10).toString(16) // "a"
  ```

   只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为`10`加上括号，还可以在`10`后面加两个点，JavaScript 会把第一个点理解成小数点（即`10.0`），把第二个点理解成调用对象属性，从而得到正确结果。 

  ```js
  10..toString(2)
  // "1010"
  
  // 其他方法还包括
  10 .toString(2) // "1010"
  
  //这实际上意味着，可以直接对一个小数使用toString方法。
  10.0.toString(2) // "1010"
  ```

   通过方括号运算符也可以调用`toString`方法。 

  ```js
  10['toString'](2) // "1010"
  ```

 `toString`方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用`parseInt`方法。 

+  `toFixed()`方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。 

  ```js
  (10).toFixed(2) // "10.00"
  10.005.toFixed(2) // "10.01"
  ```

  `toFixed()`方法的参数为小数位数，有效范围为0到100，超出这个范围将抛出 RangeError 错误。

  由于浮点数的原因，小数`5`的四舍五入是不确定的，使用的时候必须小心。

  ```js
  (10.055).toFixed(2) // 10.05
  (10.005).toFixed(2) // 10.01
  ```

+  `toExponential`方法用于将一个数转为科学计数法形式。 

  ```js
  (10).toExponential()  // "1e+1"
  (10).toExponential(1) // "1.0e+1"
  (10).toExponential(2) // "1.00e+1"
  
  (1234).toExponential()  // "1.234e+3"
  (1234).toExponential(1) // "1.2e+3"
  (1234).toExponential(2) // "1.23e+3"
  ```

   **`toExponential`方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。** 

+  `Number.prototype.toPrecision()`方法用于将一个数转为指定位数的有效数字。 

  ```js
  (12.34).toPrecision(1) // "1e+1"
  (12.34).toPrecision(2) // "12"
  (12.34).toPrecision(3) // "12.3"
  (12.34).toPrecision(4) // "12.34"
  (12.34).toPrecision(5) // "12.340"
  ```

  该方法的参数为有效数字的位数，范围是1到100，超出这个范围会抛出 RangeError 错误。

  **该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。**

+  `Number.prototype.toLocaleString()`方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。 

   该方法还可以接受第二个参数配置对象，用来定制指定用途的返回字符串。该对象的`style`属性指定输出样式，默认值是`decimal`，表示输出十进制形式。如果值为`percent`，表示输出百分数。 

  ```js
  (123).toLocaleString('zh-Hans-CN', { style: 'percent' })
  // "12,300%"
  ```

   如果`style`属性的值为`currency`，则可以搭配`currency`属性，输出指定格式的货币字符串形式。 

  ```js
  (123).toLocaleString('zh-Hans-CN', { style: 'currency', currency: 'CNY' })
  // "￥123.00"
  
  (123).toLocaleString('de-DE', { style: 'currency', currency: 'EUR' })
  // "123,00 €"
  
  (123).toLocaleString('en-US', { style: 'currency', currency: 'USD' })
  // "$123.00"
  ```

   如果`Number.prototype.toLocaleString()`省略了参数，则由浏览器自行决定如何处理，通常会使用操作系统的地区设定。注意，该方法如果使用浏览器不认识的地区码，会抛出一个错误。 

## 自定义方法

 与其他对象一样，`Number.prototype`对象上面可以自定义方法，被`Number`的实例继承。 

# String 对象

 `String`对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。 

```js
var s1 = 'abc';
var s2 = new String('abc');

typeof s1 // "string"
typeof s2 // "object"

s2.valueOf() // "abc"
```

 上面代码中，变量`s1`是字符串，`s2`是对象。由于`s2`是字符串对象，`s2.valueOf`方法返回的就是它所对应的原始字符串。 

 字符串对象是一个类似数组的对象（很像数组，但不是数组）。 

```js
new String('abc')
// String {0: "a", 1: "b", 2: "c", length: 3}

(new String('abc'))[1] // "b"
```

 上面代码中，字符串`abc`对应的字符串对象，有数值键（`0`、`1`、`2`）和`length`属性，所以可以像数组那样取值。

 除了用作构造函数，`String`对象还可以当作工具方法使用，将任意类型的值转为字符串。 

```js
String(true) // "true"
String(5) // "5"
```

## 静态方法

+  `String`对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是`String.fromCharCode()`。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。 

  ```js
  String.fromCharCode() // ""
  String.fromCharCode(97) // "a"
  String.fromCharCode(104, 101, 108, 108, 111)
  // "hello"
  ```

  上面代码中，`String.fromCharCode`方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。

  **注意，该方法不支持 Unicode 码点大于`0xFFFF`的字符，即传入的参数不能大于`0xFFFF`（即十进制的 65535）。**

  ```js
  String.fromCharCode(0x20BB7)
  // "ஷ"
  String.fromCharCode(0x20BB7) === String.fromCharCode(0x0BB7)
  // true
  ```

  上面代码中，`String.fromCharCode`参数`0x20BB7`大于`0xFFFF`，导致返回结果出错。`0x20BB7`对应的字符是汉字`𠮷`，但是返回结果却是另一个字符（码点`0x0BB7`）。这是因为`String.fromCharCode`发现参数值大于`0xFFFF`，就会忽略多出的位（即忽略`0x20BB7`里面的`2`）。

  这种现象的根本原因在于，码点大于`0xFFFF`的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把`0x20BB7`拆成两个字符表示。

  ```js
  String.fromCharCode(0xD842, 0xDFB7)
  // "𠮷"
  ```

## 实例属性

+  字符串实例的`length`属性返回字符串的长度。 

  ```js
  'abc'.length // 3
  ```

+  `charAt`方法返回指定位置的字符，参数是从`0`开始编号的位置。 

  ```js
  var s = new String('abc');
  
  s.charAt(1) // "b"
  s.charAt(s.length - 1) // "c"
  ```

   这个方法完全可以用数组下标替代。 

  ```js
  'abc'.charAt(1) // "b"
  'abc'[1] // "b"
  ```

   如果参数为负数，或大于等于字符串的长度，`charAt`返回空字符串。 

  ```js
  'abc'.charAt(-1) // ""
  'abc'.charAt(3) // ""
  ```

+  `charCodeAt()`方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于`String.fromCharCode()`的逆操作。 

  ```js
  'abc'.charCodeAt(1) // 98
  ```

   如果没有任何参数，`charCodeAt`返回首字符的 Unicode 码点。 

   如果参数为负数，或大于等于字符串的长度，`charCodeAt`返回`NaN`。 

  ```js
  'abc'.charCodeAt(-1) // NaN
  'abc'.charCodeAt(4) // NaN
  ```

   注意，`charCodeAt`方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必须连续使用两次`charCodeAt`，不仅读入`charCodeAt(i)`，还要读入`charCodeAt(i+1)`，将两个值放在一起，才能得到准确的字符。 

   `concat`方法用于连接两个字符串，返回一个新字符串，不改变原字符串。 

  ```js
  var s1 = 'abc';
  var s2 = 'def';
  
  s1.concat(s2) // "abcdef"
  s1 // "abc"
  ```

   该方法可以接受多个参数。 

  ```js
  'a'.concat('b', 'c') // "abc"
  ```

   如果参数不是字符串，`concat`方法会将其先转为字符串，然后再连接。 

  ```js
  var one = 1;
  var two = 2;
  var three = '3';
  
  ''.concat(one, two, three) // "123"
  one + two + three // "33"
  ```

   `concat`方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串。 

+  `slice()`方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。 

  ```js
  'JavaScript'.slice(0, 4) // "Java"
  
  'JavaScript'.slice(4) // "Script"
  
  'JavaScript'.slice(-6) // "Script"
  'JavaScript'.slice(0, -6) // "Java"
  'JavaScript'.slice(-2, -1) // "p"
  ```

   如果第一个参数大于第二个参数（正数情况下），`slice()`方法返回一个空字符串。 

  ```js
  'JavaScript'.slice(2, 1) // ""
  ```

+  `substring`方法用于从原字符串取出子字符串并返回，不改变原字符串，跟`slice`方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。 

  ```js
  'JavaScript'.substring(0, 4) // "Java"
  
  'JavaScript'.substring(4) // "Script"
  
  'JavaScript'.substring(10, 4) // "Script"
  // 等同于
  'JavaScript'.substring(4, 10) // "Script"
  ```

   **如果参数是负数，`substring`方法会自动将负数转为0。** 

  ```js
  'JavaScript'.substring(-3) // "JavaScript"
  'JavaScript'.substring(4, -3) // "Java"
  ```

   由于这些规则违反直觉，因此不建议使用`substring`方法，应该优先使用`slice`。 

+  `substr`方法用于从原字符串取出子字符串并返回，不改变原字符串，跟`slice`和`substring`方法的作用相同。 

  `substr`方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。

  ```js
  'JavaScript'.substr(4, 6) // "Script"
  ```

  如果省略第二个参数，则表示子字符串一直到原字符串的结束。

  ```js
  'JavaScript'.substr(4) // "Script"
  ```

  如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。

  ```js
  'JavaScript'.substr(-6) // "Script"
  'JavaScript'.substr(4, -1) // ""
  ```

  上面代码中，第二个例子的参数`-1`自动转为`0`，表示子字符串长度为`0`，所以返回空字符串。

+  `indexOf`方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回`-1`，就表示不匹配。 

  ```js
  'hello world'.indexOf('o') // 4
  'JavaScript'.indexOf('script') // -1
  ```

  ```js
  'hello world'.indexOf('o', 6) // 7
  ```

+  `lastIndexOf`方法的用法跟`indexOf`方法一致，主要的区别是`lastIndexOf`从尾部开始匹配，`indexOf`则是从头部开始匹配。 

  ```js
  'hello world'.lastIndexOf('o') // 7
  ```

  ```js
  'hello world'.lastIndexOf('o', 6) // 4
  
  //lastIndexof() 的第二个参数，还是从前往后 0 1 2 3 ...，只不过查找顺序从后往前
  ```

+  `trim`方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。 

  ```js
  '  hello world  '.trim()
  // "hello world"
  ```

   该方法去除的不仅是空格，还包括制表符（`\t`、`\v`）、换行符（`\n`）和回车符（`\r`）。 

+  `toLowerCase`方法用于将一个字符串全部转为小写，`toUpperCase`则是全部转为大写。它们都返回一个新字符串，不改变原字符串。 

  ```js
  'Hello World'.toLowerCase()
  // "hello world"
  
  'Hello World'.toUpperCase()
  // "HELLO WORLD"
  ```

+  `match`方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回`null`。 

  ```js
  'cat, bat, sat, fat'.match('at') // ["at"]
  'cat, bat, sat, fat'.match('xt') // null
  ```

  ```js
  var matches = 'cat, bat, sat, fat'.match('at');
  matches.index // 1
  matches.input // "cat, bat, sat, fat"
  ```

   `match`方法还可以使用正则表达式作为参数，详见《正则表达式》一章。 

+  `search`方法的用法基本等同于`match`，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回`-1`。 

  ```js
  'cat, bat, sat, fat'.search('at') // 1
  ```

   `search`方法还可以使用正则表达式作为参数，详见《正则表达式》一节。 

  `replace`方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有`g`修饰符的正则表达式）。

  ```js
  'aaa'.replace('a', 'b') // "baa"
  ```

  `replace`方法还可以使用正则表达式作为参数，详见《正则表达式》一节。

+  `split`方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 

  ```js
  'a|b|c'.split('|') // ["a", "b", "c"]
  ```

   如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。 

  ```js
  'a|b|c'.split('') // ["a", "|", "b", "|", "c"]
  ```

  ```js
  'a|b|c'.split() // ["a|b|c"]
  ```

   如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。 

  ```js
  'a||c'.split('|') // ['a', '', 'c']
  ```

   如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。 

  ```js
  '|b|c'.split('|') // ["", "b", "c"]
  'a|b|'.split('|') // ["a", "b", ""]
  ```

   `split`方法还可以接受第二个参数，限定返回数组的最大成员数。 

  ```js
  'a|b|c'.split('|', 0) // []
  'a|b|c'.split('|', 1) // ["a"]
  'a|b|c'.split('|', 2) // ["a", "b"]
  'a|b|c'.split('|', 3) // ["a", "b", "c"]
  'a|b|c'.split('|', 4) // ["a", "b", "c"]
  ```

  上面代码中，`split`方法的第二个参数，决定了返回数组的成员数。

  `split`方法还可以使用正则表达式作为参数，详见《正则表达式》一节

+  `localeCompare`方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 

  ```js
  'apple'.localeCompare('banana') // -1
  'apple'.localeCompare('apple') // 0
  ```

   该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。 

  字母`B`小于字母`a`。因为 JavaScript 采用的是 Unicode 码点比较，`B`的码点是66，而`a`的码点是97。

  但是，`localeCompare`方法会考虑自然语言的排序情况，将`B`排在`a`的前面。

   `localeCompare`还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。 

  ```js
  'ä'.localeCompare('z', 'de') // -1
  'ä'.localeCompare('z', 'sv') // 1
  ```

# Math 对象

## 静态属性

`Math`对象的静态属性，提供以下一些数学常数。

- `Math.E`：常数`e`。
- `Math.LN2`：2 的自然对数。
- `Math.LN10`：10 的自然对数。
- `Math.LOG2E`：以 2 为底的`e`的对数。
- `Math.LOG10E`：以 10 为底的`e`的对数。
- `Math.PI`：常数`π`。
- `Math.SQRT1_2`：0.5 的平方根。
- `Math.SQRT2`：2 的平方根。

```JS
Math.E // 2.718281828459045
Math.LN2 // 0.6931471805599453
Math.LN10 // 2.302585092994046
Math.LOG2E // 1.4426950408889634
Math.LOG10E // 0.4342944819032518
Math.PI // 3.141592653589793
Math.SQRT1_2 // 0.7071067811865476
Math.SQRT2 // 1.4142135623730951
```

## 静态方法

`Math`对象提供以下一些静态方法。

- `Math.abs()`：绝对值

  ```
  Math.abs(1) // 1
  Math.abs(-1) // 1
  ```



- `Math.ceil()`：向上取整

   `Math.ceil`方法返回大于或等于参数值的最小整数（天花板值）。 

- `Math.floor()`：向下取整

   `Math.floor`方法返回小于或等于参数值的最大整数（地板值）。 

  这两个方法可以结合起来，实现一个总是返回数值的整数部分的函数。

  ```js
  function ToInteger(x) {
    x = Number(x);
    return x < 0 ? Math.ceil(x) : Math.floor(x);
  }
  
  ToInteger(3.2) // 3
  ToInteger(3.5) // 3
  ToInteger(3.8) // 3
  ToInteger(-3.2) // -3
  ToInteger(-3.5) // -3
  ToInteger(-3.8) // -3
  ```



- `Math.max()`：最大值

   `Math.max`方法返回参数之中最大的那个值 

- `Math.min()`：最小值

   `Math.min`返回最小的那个值。 

 如果参数为空, `Math.min`返回`Infinity`, `Math.max`返回`-Infinity`。 



- `Math.pow()`：幂运算

   `Math.pow`方法返回以第一个参数为底数、第二个参数为指数的幂运算值。 



- `Math.sqrt()`：平方根

   `Math.sqrt`方法返回参数值的平方根。如果参数是一个负值，则返回`NaN`。 



- `Math.log()`：自然对数

   `Math.log`方法返回以`e`为底的自然对数值。 

  ```js
  Math.log(Math.E) // 1
  Math.log(10) // 2.302585092994046
  ```

  

- `Math.exp()`：`e`的指数

   `Math.exp`方法返回常数`e`的参数次方。 



- `Math.round()`：四舍五入

   注意，它对负数的处理（主要是对`0.5`的处理）。 

  ```js
  Math.round(-1.1) // -1
  
  Math.round(-1.5) // -1
  //对于负数0.5不进位
  
  Math.round(-1.6) // -2
  ```

  

- `Math.random()`：随机数

   `Math.random()`返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 

  ```JS
  //任意范围的随机数
  function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
  }
  
  getRandomArbitrary(1.5, 6.5)
  // 2.4942810038223864
  ```

  ```js
  //返回随机字符的例子如下。
  function random_str(length) {
    var ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    ALPHABET += 'abcdefghijklmnopqrstuvwxyz';
    ALPHABET += '0123456789-_';
    var str = '';
    for (var i = 0; i < length; ++i) {
      var rand = Math.floor(Math.random() * ALPHABET.length);
      str += ALPHABET.substring(rand, rand + 1);
    }
    return str;
  }
  
  random_str(6) // "NdQKOr"
  ```

`Math`对象还提供一系列三角函数方法。

- `Math.sin()`：返回参数的正弦（参数为弧度值）
- `Math.cos()`：返回参数的余弦（参数为弧度值）
- `Math.tan()`：返回参数的正切（参数为弧度值）
- `Math.asin()`：返回参数的反正弦（返回值为弧度值）
- `Math.acos()`：返回参数的反余弦（返回值为弧度值）
- `Math.atan()`：返回参数的反正切（返回值为弧度值）

```js
Math.sin(0) // 0
Math.cos(0) // 1
Math.tan(0) // 0

Math.sin(Math.PI / 2) // 1

Math.asin(1) // 1.5707963267948966
Math.acos(1) // 0
Math.atan(1) // 0.7853981633974483
```

# Date 对象

 `Date`对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。 

## 普通函数的用法

`Date`对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。

```js
Date()
// 'Mon Jan 10 2022 16:09:38 GMT+0800 (中国标准时间)'
```

注意，即使带有参数，`Date`作为普通函数使用时，返回的还是当前时间。

```js
Date(2000, 1, 1)
//'Mon Jan 10 2022 16:10:02 GMT+0800 (中国标准时间)'
```

上面代码说明，无论有没有参数，直接调用`Date`总是返回当前时间。

## 构造函数的用法

 `Date`还可以当作构造函数使用。对它使用`new`命令，会返回一个`Date`对象的实例。如果不加参数，实例代表的就是当前时间。 

```js
var today = new Date();
```

`Date`实例有一个独特的地方。其他对象求值的时候，都是默认调用`.valueOf()`方法，但是`Date`实例求值的时候，默认调用的是`toString()`方法。这导致对`Date`实例求值，返回的是一个字符串，代表该实例对应的时间。

```js
var today = new Date();

today
// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"

// 等同于
today.toString()
// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"
```

 上面代码中，`today`是`Date`的实例，直接求值等同于调用`toString`方法。 

关于`Date`构造函数的参数，有几点说明。

第一点，参数可以是负整数，代表1970年元旦之前的时间。

```
new Date(-1378218728000)
// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)
```

第二点，只要是能被`Date.parse()`方法解析的字符串，都可以当作参数。

```js
new Date('2013-2-15')
new Date('2013/2/15')
new Date('02/15/2013')
new Date('2013-FEB-15')
new Date('FEB, 15, 2013')
new Date('FEB 15, 2013')
new Date('February, 15, 2013')
new Date('February 15, 2013')
new Date('15 Feb 2013')
new Date('15, February, 2013')
// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)
```

 上面多种日期字符串的写法，返回的都是同一个时间。 

 参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，`Date`会将其解释为毫秒数。 

```js
new Date(2013)
// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)
```

最后，各个参数的取值范围如下。

- 年：使用四位数年份，比如`2000`。如果写成两位数或个位数，则加上`1900`，即`10`代表1910年。如果是负数，表示公元前。
- 月：`0`表示一月，依次类推，`11`表示12月。
- 日：`1`到`31`。
- 小时：`0`到`23`。
- 分钟：`0`到`59`。
- 秒：`0`到`59`
- 毫秒：`0`到`999`。

**注意，月份从`0`开始计算，但是，天数从`1`开始计算。另外，除了日期的默认值为`1`，小时、分钟、秒钟和毫秒的默认值都是`0`。**

这些参数如果超出了正常范围，会被自动折算。比如，如果月设为`15`，就折算为下一年的4月。

上面代码的第二个例子，日期设为`0`，就代表上个月的最后一天。

参数还可以使用负数，表示扣去的时间。

## 日期的运算

类型自动转换时，`Date`实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。 

## 静态方法

+  `Date.now`方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000 

  ```js
  Date.now() // 1364026285194
  ```

+  `Date.parse`方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。 

  日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即`YYYY-MM-DDTHH:mm:ss.sssZ`格式，其中最后的`Z`表示时区。但是，其他格式也可以被解析，请看下面的例子。 

  ```
  Date.parse('Aug 9, 1995')
  Date.parse('January 26, 2011 13:51:50')
  Date.parse('Mon, 25 Dec 1995 13:30:00 GMT')
  Date.parse('Mon, 25 Dec 1995 13:30:00 +0430')
  Date.parse('2011-10-10')
  Date.parse('2011-10-10T14:48:00')
  ```

  上面的日期字符串都可以解析。 

  如果解析失败，返回`NaN`。

  ```js
  Date.parse('xxx') // NaN
  ```

+  `Date.UTC`方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。 

  ```js
  // 格式
  Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])
  
  // 用法
  Date.UTC(2011, 0, 1, 2, 3, 4, 567)
  // 1293847384567
  ```

## 实例方法

+ `valueOf`方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，

+ 该方法等同于`getTime`方法。 

  ```js
  var d = new Date();
  
  d.valueOf() // 1362790014817
  d.getTime() // 1362790014817
  ```

### to 类方法

+  `toString`方法返回一个完整的日期字符串。 

  ```js
  var d = new Date(2013, 0, 1);
  
  d.toString()
  // "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"
  d
  // "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"
  ```

   因为`toString`是默认的调用方法，所以如果直接读取`Date`实例，就相当于调用这个方法。 

+  `toUTCString`方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。 

+  `toISOString`方法返回对应时间的 ISO8601 写法。 

+  `toJSON`方法返回一个符合 JSON 格式的 ISO 日期字符串，与`toISOString`方法的返回结果完全相同。 

  ```js
  var d = new Date(2013, 0, 1);
  
  d.toJSON()
  // "2012-12-31T16:00:00.000Z"
  ```

+  `toDateString`方法返回日期字符串（不含小时、分和秒）。 

  ```js
  var d = new Date(2013, 0, 1);
  d.toDateString() // "Tue Jan 01 2013"
  ```

+  `toTimeString`方法返回时间字符串（不含年月日）。 

+  **本地时间** 

  + `Date.prototype.toLocaleString()`：完整的本地时间。
  + `Date.prototype.toLocaleDateString()`：本地日期（不含小时、分和秒）。
  + `Date.prototype.toLocaleTimeString()`：本地时间（不含年月日）。

  ```JS
  var d = new Date(2013, 0, 1);
  
  d.toLocaleString()
  // 中文版浏览器为"2013年1月1日 上午12:00:00"
  // 英文版浏览器为"1/1/2013 12:00:00 AM"
  
  d.toLocaleDateString()
  // 中文版浏览器为"2013年1月1日"
  // 英文版浏览器为"1/1/2013"
  
  d.toLocaleTimeString()
  // 中文版浏览器为"上午12:00:00"
  // 英文版浏览器为"12:00:00 AM"
  ```

  这三个方法都有两个可选的参数。

  ```JS
  dateObj.toLocaleString([locales[, options]])
  dateObj.toLocaleDateString([locales[, options]])
  dateObj.toLocaleTimeString([locales[, options]])
  ```

  ```JS
  var d = new Date(2013, 0, 1);
  
  d.toLocaleString('en-US') // "1/1/2013, 12:00:00 AM"
  d.toLocaleString('zh-CN') // "2013/1/1 上午12:00:00"
  
  d.toLocaleDateString('en-US') // "1/1/2013"
  d.toLocaleDateString('zh-CN') // "2013/1/1"
  
  d.toLocaleTimeString('en-US') // "12:00:00 AM"
  d.toLocaleTimeString('zh-CN') // "上午12:00:00"
  ```

  `options`配置对象有以下属性。

  - `dateStyle`：可能的值为`full`、`long`、`medium`、`short`。
  - `timeStyle`：可能的值为`full`、`long`、`medium`、`short`。
  - `month`：可能的值为`numeric`、`2-digit`、`long`、`short`、`narrow`。
  - `year`：可能的值为`numeric`、`2-digit`。
  - `weekday`：可能的值为`long`、`short`、`narrow`。
  - `day`、`hour`、`minute`、`second`：可能的值为`numeric`、`2-digit`。
  - `timeZone`：可能的值为 IANA 的时区数据库。
  - `timeZooneName`：可能的值为`long`、`short`。
  - `hour12`：24小时周期还是12小时周期，可能的值为`true`、`false`。

  ```JS
  var d = new Date(2013, 0, 1);
  
  d.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
  // "Tuesday, January 1, 2013"
  
  d.toLocaleDateString('en-US', {
    day: "2-digit",
    month: "long",
    year: "2-digit"
  });
  // "January 01, 13"
  
  d.toLocaleTimeString('en-US', {
    timeZone: 'UTC',
    timeZoneName: 'short'
  })
  // "4:00:00 PM UTC"
  
  d.toLocaleTimeString('en-US', {
    timeZone: 'Asia/Shanghai',
    timeZoneName: 'long'
  })
  // "12:00:00 AM China Standard Time"
  
  d.toLocaleTimeString('en-US', {
    hour12: false
  })
  // "00:00:00"
  
  d.toLocaleTimeString('en-US', {
    hour12: true
  })
  // "12:00:00 AM"
  ```

  

### get 类方法

`Date`对象提供了一系列`get*`方法，用来获取实例对象某个方面的值。

- `getTime()`：返回实例距离1970年1月1日00:00:00的毫秒数，等同于`valueOf`方法。
- `getDate()`：返回实例对象对应每个月的几号（从1开始）。
- `getDay()`：返回星期几，星期日为0，星期一为1，以此类推。
- `getFullYear()`：返回四位的年份。
- `getMonth()`：返回月份（0表示1月，11表示12月）。
- `getHours()`：返回小时（0-23）。
- `getMilliseconds()`：返回毫秒（0-999）。
- `getMinutes()`：返回分钟（0-59）。
- `getSeconds()`：返回秒（0-59）。
- `getTimezoneOffset()`：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。

所有这些`get*`方法返回的都是整数，不同方法返回值的范围不一样。

- 分钟和秒：0 到 59
- 小时：0 到 23
- 星期：0（星期天）到 6（星期六）
- 日期：1 到 31
- 月份：0（一月）到 11（十二月）

```js
var d = new Date('January 6, 2013');

d.getDate() // 6
d.getMonth() // 0
d.getFullYear() // 2013
d.getTimezoneOffset() // -480
```

- `getUTCDate()`
- `getUTCFullYear()`
- `getUTCMonth()`
- `getUTCDay()`
- `getUTCHours()`
- `getUTCMinutes()`
- `getUTCSeconds()`
- `getUTCMilliseconds()`

### set 类方法

`Date`对象提供了一系列`set*`方法，用来设置实例对象的各个方面。

- `setDate(date)`：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。
- `setFullYear(year [, month, date])`：设置四位年份。
- `setHours(hour [, min, sec, ms])`：设置小时（0-23）。
- `setMilliseconds()`：设置毫秒（0-999）。
- `setMinutes(min [, sec, ms])`：设置分钟（0-59）。
- `setMonth(month [, date])`：设置月份（0-11）。
- `setSeconds(sec [, ms])`：设置秒（0-59）。
- `setTime(milliseconds)`：设置毫秒时间戳。

# RegExp 对象

正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。

新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。

```js
var regex = /xyz/;
```

另一种是使用`RegExp`构造函数。

```js
var regex = new RegExp('xyz');
```

上面两种写法是等价的，都新建了一个内容为`xyz`的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。

`RegExp`构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。

```js
var regex = new RegExp('xyz', 'i');
// 等价于
var regex = /xyz/i;
```

上面代码中，正则表达式`/xyz/`有一个修饰符`i`。

## 实例属性

一类是修饰符相关，用于了解设置了什么修饰符。

- `RegExp.prototype.ignoreCase`：返回一个布尔值，表示是否设置了`i`修饰符。
- `RegExp.prototype.global`：返回一个布尔值，表示是否设置了`g`修饰符。
- `RegExp.prototype.multiline`：返回一个布尔值，表示是否设置了`m`修饰符。
- `RegExp.prototype.flags`：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。

```js
var r = /abc/igm;

r.ignoreCase // true
r.global // true
r.multiline // true
r.flags // 'gim'
```

另一类是与修饰符无关的属性，主要是下面两个。

- `RegExp.prototype.lastIndex`：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。
- `RegExp.prototype.source`：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。

```js
var r = /abc/igm;

r.lastIndex // 0
r.source // "abc"
```

 正则实例对象的`test`方法返回一个布尔值，表示当前模式是否能匹配参数字符串。 

```js
/cat/.test('cats and dogs') // true
```

上面代码验证参数字符串之中是否包含`cat`，结果返回`true`。

如果正则表达式带有`g`修饰符，则每一次`test`方法都从上一次结束的位置开始向后匹配。

```js
var r = /x/g;
var s = '_x_x';

r.lastIndex // 0
r.test(s) // true

r.lastIndex // 2
r.test(s) // true

r.lastIndex // 4
r.test(s) // false
```

 上面代码的正则表达式使用了`g`修饰符，表示是全局搜索，会有多个结果。接着，三次使用`test`方法，每一次开始搜索的位置都是上一次匹配的后一个位置。 

 带有`g`修饰符时，可以通过正则对象的`lastIndex`属性指定开始搜索的位置。 

```js
var r = /x/g;
var s = '_x_x';

r.lastIndex = 4;
r.test(s) // false

r.lastIndex // 0
r.test(s)
```

上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回`false`。同时，`lastIndex`属性重置为`0`，所以第二次执行`r.test(s)`会返回`true`。

注意，带有`g`修饰符时，正则表达式内部会记住上一次的`lastIndex`属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。

 `lastIndex`属性只对同一个正则表达式有效，所以下面这样写是错误的。 

```js
var count = 0;
while (/a/g.test('babaa')) count++;
```

 上面代码会导致无限循环，因为`while`循环的每次匹配条件都是一个新的正则表达式，导致`lastIndex`属性总是等于0。 

### `RegExp.prototype.exec()`

 正则实例对象的`exec()`方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回`null`。 

```js
var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

r1.exec(s) // ["x"]
r2.exec(s) // null
```

 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的`length`属性等于组匹配的数量再加1。 

`exec()`方法的返回数组还包含以下两个属性：

- `input`：整个原字符串。
- `index`：模式匹配成功的开始位置（从0开始计数）。

```js
var r = /a(b+)a/;
var arr = r.exec('_abbba_aba_');

arr // ["abbba", "bbb"]

arr.index // 1
//上面代码中的index属性等于1，是因为从原字符串的第二个位置开始匹配成功。

arr.input // "_abbba_aba_"
```

```js
var reg = /a/g;
var str = 'abc_abc_abc'

var r1 = reg.exec(str);
r1 // ["a"]
r1.index // 0
reg.lastIndex // 1

var r2 = reg.exec(str);
r2 // ["a"]
r2.index // 4
reg.lastIndex // 5

var r3 = reg.exec(str);
r3 // ["a"]
r3.index // 8
reg.lastIndex // 9

var r4 = reg.exec(str);
r4 // null
reg.lastIndex // 0
```

上面代码连续用了四次`exec()`方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回`null`，正则实例对象的`lastIndex`属性也重置为`0`，意味着第四次匹配将从头开始。

利用`g`修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。

```js
var reg = /a/g;
var str = 'abc_abc_abc'

while(true) {
  var match = reg.exec(str);
  if (!match) break;
  console.log('#' + match.index + ':' + match[0]);
}
// #0:a
// #4:a
// #8:a
```

上面代码中，只要`exec()`方法不返回`null`，就会一直循环下去，每次输出匹配的位置和匹配的文本。

正则实例对象的`lastIndex`属性不仅可读，还可写。设置了`g`修饰符的时候，只要手动设置了`lastIndex`的值，就会从指定位置开始匹配。

## 字符串的实例方法

字符串的实例方法之中，有4种与正则表达式有关。

- `String.prototype.match()`：返回一个数组，成员是所有匹配的子字符串。

   字符串实例对象的`match`方法对字符串进行正则匹配，返回匹配结果。 

  ```js
  var s = '_x_x';
  var r1 = /x/;
  var r2 = /y/;
  
  s.match(r1) // ["x"]
  s.match(r2) // null
  ```

   如果正则表达式带有`g`修饰符，则该方法与正则对象的`exec`方法行为不同，会一次性返回所有匹配成功的结果。 

  ```js
  var s = 'abba';
  var r = /a/g;
  
  s.match(r) // ["a", "a"]
  r.exec(s) // ["a"]
  ```

   设置正则表达式的`lastIndex`属性，对`match`方法无效，匹配总是从字符串的第一个字符开始。 



- `String.prototype.search()`：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。

   字符串对象的`search`方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回`-1`。 

  ```js
  '_x_x'.search(/x/)
  // 1
  ```



- `String.prototype.replace()`：按照给定的正则表达式进行替换，返回替换后的字符串。

   字符串对象的`replace`方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。 

  ```js
  str.replace(search, replacement)
  ```

   正则表达式如果不加`g`修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。 

  ```js
  'aaa'.replace('a', 'b') // "baa"
  'aaa'.replace(/a/, 'b') // "baa"
  'aaa'.replace(/a/g, 'b') // "bbb"
  ```

   `replace`方法的一个应用，就是消除字符串首尾两端的空格。 

  ```js
  var str = '  #id div.class  ';
  
  str.replace(/^\s+|\s+$/g, '')
  // "#id div.class"
  ```

  `replace`方法的第二个参数可以使用美元符号`$`，用来指代所替换的内容。

  - `$&`：匹配的子字符串。

  - `$``：匹配结果前面的文本。

  - `$'`：匹配结果后面的文本。

  - `$n`：匹配成功的第`n`组内容，`n`是从1开始的自然数。

  - `$$`：指代美元符号`$`。

    ```js
    'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
    // "world hello"
    
    'abc'.replace('b', '[$`-$&-$\']')
    // "a[a-b-c]c"
    ```

     `replace`方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。 

    ```js
    '3 and 5'.replace(/[0-9]+/g, function (match) {
      return 2 * match;
    })
    // "6 and 10"
    
    var a = 'The quick brown fox jumped over the lazy dog.';
    var pattern = /quick|brown|lazy/ig;
    
    a.replace(pattern, function replacer(match) {
      return match.toUpperCase();
    });
    // The QUICK BROWN fox jumped over the LAZY dog.
    ```

     作为`replace`方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。 

    ```js
    var prices = {
      'p1': '$1.99',
      'p2': '$9.99',
      'p3': '$5.00'
    };
    
    var template = '<span id="p1"></span>'
      + '<span id="p2"></span>'
      + '<span id="p3"></span>';
    
    template.replace(
      /(<span id=")(.*?)(">)(<\/span>)/g,
      function(match, $1, $2, $3, $4){
        return $1 + $2 + $3 + prices[$2] + $4;
      }
    );
    // "<span id="p1">$1.99</span><span id="p2">$9.99</span><span id="p3">$5.00</span>"
    ```

     上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用`$1`到`$4`表示。匹配函数的作用是将价格插入模板中。 



- `String.prototype.split()`：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

   字符串对象的`split`方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。 

  ```js
  str.split(separator, [limit])
  ```

   该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。 

  ```js
  // 非正则分隔
  'a,  b,c, d'.split(',')
  // [ 'a', '  b', 'c', ' d' ]
  
  // 正则分隔，去除多余的空格
  'a,  b,c, d'.split(/, */)
  // [ 'a', 'b', 'c', 'd' ]
  
  // 指定返回数组的最大成员
  'a,  b,c, d'.split(/, */, 2)
  [ 'a', 'b' ]
  ```

  ```js
  // 例一
  'aaa*a*'.split(/a*/)
  // [ '', '*', '*' ]
  
  // 例二
  'aaa**a*'.split(/a*/)
  // ["", "*", "*", "*"]
  ```

  上面代码的分割规则是0次或多次的`a`，由于正则默认是贪婪匹配，所以例一的第一个分隔符是`aaa`，第二个分割符是`a`，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是`aaa`，第二个分隔符是0个`a`（即空字符），第三个分隔符是`a`，所以将字符串分成四个部分。

  如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。

  ```js
  'aaa*a*'.split(/(a*)/)
  // [ '', 'aaa', '*', 'a', '*' ]
  ```

  上面代码的正则表达式使用了括号，第一个组匹配是`aaa`，第二个组匹配是`a`，它们都作为数组成员返回。

## 匹配规则

### 字面量字符和元字符

 大部分字符在正则表达式中，就是字面的含义，比如`/a/`匹配`a`，`/b/`匹配`b`。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的`a`和`b`），那么它们就叫做“字面量字符”（literal characters）。 

```js
/dog/.test('old dog') // true
```

上面代码中正则表达式的`dog`，就是字面量字符，所以`/dog/`匹配`old dog`，因为它就表示`d`、`o`、`g`三个字母连在一起。

除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。

**（1）点字符（.)**

点字符（`.`）匹配除回车（`\r`）、换行(`\n`) 、行分隔符（`\u2028`）和段分隔符（`\u2029`）以外的所有字符。注意，对于码点大于`0xFFFF`字符，点字符不能正确匹配，会认为这是两个字符。

```js
/c.t/
```

上面代码中，`c.t`匹配`c`和`t`之间包含任意一个字符的情况，只要这三个字符在同一行，比如`cat`、`c2t`、`c-t`等等，但是不匹配`coot`。

 **（2）位置字符** 

位置字符用来提示字符所处的位置，主要有两个字符。

- `^` 表示字符串的开始位置
- `$` 表示字符串的结束位置

```js
// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false
```

**（3）选择符（`|`）**

竖线符号（`|`）在正则表达式中表示“或关系”（OR），即`cat|dog`表示匹配`cat`或`dog`。

```js
/11|22/.test('911') // true
```

上面代码中，正则表达式指定必须匹配`11`或`22`。

### 转义符

正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配`+`，就要写成`\+`。

```js
/1+1/.test('1+1')
// false

/1\+1/.test('1+1')
// true
```

上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。

 正则表达式中，需要反斜杠转义的，一共有12个字符：`^`、`.`、`[`、`$`、`(`、`)`、`|`、`*`、`+`、`?`、`{`和`\`。需要特别注意的是，如果使用`RegExp`方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。 

 **需要特别注意的是，如果使用`RegExp`方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。** 

 上面代码中，`RegExp`作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。 

### 特殊字符

正则表达式对一些不能打印的特殊字符，提供了表达方法。

- `\cX` 表示`Ctrl-[X]`，其中的`X`是A-Z之中任一个英文字母，用来匹配控制字符。
- `[\b]` 匹配退格键(U+0008)，不要与`\b`混淆。
- `\n` 匹配换行键。
- `\r` 匹配回车键。
- `\t` 匹配制表符 tab（U+0009）。
- `\v` 匹配垂直制表符（U+000B）。
- `\f` 匹配换页符（U+000C）。
- `\0` 匹配`null`字符（U+0000）。
- `\xhh` 匹配一个以两位十六进制数（`\x00`-`\xFF`）表示的字符。
- `\uhhhh` 匹配一个以四位十六进制数（`\u0000`-`\uFFFF`）表示的 Unicode 字符。

### 字符类

字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如`[xyz]` 表示`x`、`y`、`z`之中任选一个匹配。

```js
/[abc]/.test('hello world') // false
/[abc]/.test('apple') // true
```

上面代码中，字符串`hello world`不包含`a`、`b`、`c`这三个字母中的任一个，所以返回`false`；字符串`apple`包含字母`a`，所以返回`true`。

有两个字符在字符类中有特殊含义。

 **（1）脱字符（^）** 

 如果方括号内的第一个字符是`[^]`，则表示除了字符类之中的字符，其他字符都可以匹配。  比如，`[^abc]`表示除了`a`、`b`、`c`之外都可以匹配。 

```js
/[^abc]/.test('bbc news') // true
/[^abc]/.test('bbc') // false
```

 上面代码中，字符串`bbc news`包含`a`、`b`、`c`以外的其他字符，所以返回`true`；字符串`bbc`不包含`a`、`b`、`c`以外的其他字符，所以返回`false`。 

 如果方括号内没有其他字符，即只有`[^]`，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（`.`）是不包括换行符的。 

```js
var s = 'Please yes\nmake my day!';

s.match(/yes.*day/) // null
s.match(/yes[^]*day/) // [ 'yes\nmake my day']
```

上面代码中，字符串`s`含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式`[^]`包含一切字符，所以匹配成功。

> 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。 

**连字符（-）**

某些情况下，对于连续序列的字符，连字符（`-`）用来提供简写形式，表示字符的连续范围。比如，`[abc]`可以写成`[a-c]`，`[0123456789]`可以写成`[0-9]`，同理`[A-Z]`表示26个大写字母。

```js
/a-z/.test('b') // false
/[a-z]/.test('b') // true
```

 上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符`b`。只有当连字号用在方括号之中，才表示连续的字符序列。 

以下都是合法的字符类简写形式。

```js
[0-9.,]
[0-9a-fA-F]
[a-zA-Z0-9-]
[1-31]
//字符类[1-31]，不代表1到31，只代表1到3。
```

 连字符还可以用来指定 Unicode 字符的范围。 

```js
var str = "\u0130\u0131\u0132";
/[\u0128-\uFFFF]/.test(str)
// true
```

预定义模式指的是某些常见模式的简写方式。

- `\d` 匹配0-9之间的任一数字，相当于`[0-9]`。
- `\D` 匹配所有0-9以外的字符，相当于`[^0-9]`。
- `\w` 匹配任意的字母、数字和下划线，相当于`[A-Za-z0-9_]`。
- `\W` 除所有字母、数字和下划线以外的字符，相当于`[^A-Za-z0-9_]`。
- `\s` 匹配空格（包括换行符、制表符、空格符等），相等于`[ \t\r\n\v\f]`。
- `\S` 匹配非空格的字符，相当于`[^ \t\r\n\v\f]`。
- `\b` 匹配词的边界。
- `\B` 匹配非词边界，即在词的内部。

```js
// \s 的例子
/\s\w*/.exec('hello world') // [" world"]

// \b 的例子
/\bworld/.test('hello world') // true
/\bworld/.test('hello-world') // true
/\bworld/.test('helloworld') // false

// \B 的例子
/\Bworld/.test('hello-world') // false
/\Bworld/.test('helloworld') // true
```

通常，正则表达式遇到换行符（`\n`）就会停止匹配。

```
var html = "<b>Hello</b>\n<i>world!</i>";

/.*/.exec(html)[0]
// "<b>Hello</b>"
```

上面代码中，字符串`html`包含一个换行符，结果点字符（`.`）不匹配换行符，导致匹配结果可能不符合原意。这时使用`\s`字符类，就能包括换行符。

```js
var html = "<b>Hello</b>\n<i>world!</i>";

/[\S\s]*/.exec(html)[0]
// "<b>Hello</b>\n<i>world!</i>"
```

上面代码中，`[\S\s]`指代一切字符。

模式的精确匹配次数，使用大括号（`{}`）表示。`{n}`表示恰好重复`n`次，`{n,}`表示至少重复`n`次，`{n,m}`表示重复不少于`n`次，不多于`m`次。

```js
/lo{2}k/.test('look') // true
/lo{2,5}k/.test('looook') // true
```

上面代码中，第一个模式指定`o`连续出现2次，第二个模式指定`o`连续出现2次到5次之间。

### 量词符

量词符用来设定某个模式出现的次数。

- `?` 问号表示某个模式出现0次或1次，等同于`{0, 1}`。
- `*` 星号表示某个模式出现0次或多次，等同于`{0,}`。
- `+` 加号表示某个模式出现1次或多次，等同于`{1,}`。

```js
// t 出现0次或1次
/t?est/.test('test') // true
/t?est/.test('est') // true

// t 出现1次或多次
/t+est/.test('test') // true
/t+est/.test('ttest') // true
/t+est/.test('est') // false

// t 出现0次或多次
/t*est/.test('test') // true
/t*est/.test('ttest') // true
/t*est/.test('tttest') // true
/t*est/.test('est') // true
```

### 贪婪模式

 默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。这被称为贪婪模式。 

```js
var s = 'aaa';
s.match(/a+/) // ["aaa"]
```

 上面代码中，模式是`/a+/`，表示匹配1个`a`或多个`a`，那么到底会匹配几个`a`呢？因为默认是贪婪模式，会一直匹配到字符`a`不出现为止，所以匹配结果是3个`a`。 

 除了贪婪模式，还有非贪婪模式，即最小可能匹配。只要一发现匹配，就返回结果，不要往下检查。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。 

```js
var s = 'aaa';
s.match(/a+?/) // ["a"]
```

上面例子中，模式结尾添加了一个问号`/a+?/`，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配，`+?`表示只要发现一个`a`，就不再往下匹配了。

除了非贪婪模式的加号（`+?`），还有非贪婪模式的星号（`*?`）和非贪婪模式的问号（`??`）。

- `+?`：表示某个模式出现1次或多次，匹配时采用非贪婪模式。
- `*?`：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
- `??`：表格某个模式出现0次或1次，匹配时采用非贪婪模式。

### 修饰符

修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。

修饰符可以单个使用，也可以多个一起使用。

```js
// 单个修饰符
var regex = /test/i;

// 多个修饰符
var regex = /test/ig;
```

**（1）g 修饰符**

默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。`g`修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

```js
var regex = /b/;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // true
```

上面代码中，正则模式不含`g`修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回`true`。

```js
var regex = /b/g;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // false
```

上面代码中，正则模式含有`g`修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串`abba`只有两个`b`，所以前两次匹配结果为`true`，第三次匹配结果为`false`。

**（2）i 修饰符**

默认情况下，正则对象区分字母的大小写，加上`i`修饰符以后表示忽略大小写（ignoreCase）。

```js
/abc/.test('ABC') // false
/abc/i.test('ABC') // true
```

上面代码表示，加了`i`修饰符以后，不考虑大小写，所以模式`abc`匹配字符串`ABC`。

**（3）m 修饰符**

`m`修饰符表示多行模式（multiline），会修改`^`和`$`的行为。默认情况下（即不加`m`修饰符时），`^`和`$`匹配字符串的开始处和结尾处，加上`m`修饰符以后，`^`和`$`还会匹配行首和行尾，即`^`和`$`会识别换行符（`\n`）。

```js
/world$/.test('hello world\n') // false
/world$/m.test('hello world\n') // true
```

上面的代码中，字符串结尾处有一个换行符。如果不加`m`修饰符，匹配不成功，因为字符串的结尾不是`world`；加上以后，`$`可以匹配行尾。

```js
/^b/m.test('a\nb') // true
```

上面代码要求匹配行首的`b`，如果不加`m`修饰符，就相当于`b`只能处在字符串的开始处。加上`m`修饰符以后，换行符`\n`也会被认为是一行的开始。

### 组匹配

**（1）概述**

正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

```js
/fred+/.test('fredd') // true
/(fred)+/.test('fredfred') // true
```

上面代码中，第一个模式没有括号，结果`+`只表示重复字母`d`，第二个模式有括号，结果`+`就表示匹配`fred`这个词。

# JSON 对象

SON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。

相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。

每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。

> 1. 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。
> 2. 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和`null`（不能使用`NaN`, `Infinity`, `-Infinity`和`undefined`）。
> 3. 字符串必须使用双引号表示，不能使用单引号。
> 4. 对象的键名必须放在双引号里面。
> 5. 数组或对象最后一个成员的后面，不能加逗号。

以下都是合法的 JSON。

```json
["one", "two", "three"]

{ "one": 1, "two": 2, "three": 3 }

{"names": ["张三", "李四"] }

[ { "name": "张三"}, {"name": "李四"} ]
```

以下都是不合法的 JSON。

```json
{ name: "张三", 'age': 32 }  // 属性名必须使用双引号

[32, 64, 128, 0xFFF] // 不能使用十六进制值

{ "name": "张三", "age": undefined } // 不能使用 undefined

{ "name": "张三",
  "birthday": new Date('Fri, 26 Aug 2011 07:13:10 GMT'),
  "getName": function () {
      return this.name;
  }
} // 属性值不能使用函数和日期对象
```

注意，`null`、空数组和空对象都是合法的 JSON 值。

## JSON 对象

 `JSON`对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：`JSON.stringify()`和`JSON.parse()`。 

+  `JSON.stringify()`方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被`JSON.parse()`方法还原。 

  ```js
  JSON.stringify('abc') // ""abc""
  JSON.stringify(1) // "1"
  JSON.stringify(false) // "false"
  JSON.stringify([]) // "[]"
  JSON.stringify({}) // "{}"
  
  JSON.stringify([1, "false", false])
  // '[1,"false",false]'
  
  JSON.stringify({ name: "张三" })
  // '{"name":"张三"}'
  ```

  上面代码将各种类型的值，转成 JSON 字符串。

  注意，对于原始类型的字符串，转换结果会带双引号。

  ```js
  JSON.stringify('foo') === "foo" // false
  JSON.stringify('foo') === "\"foo\"" // true
  ```

   如果对象的属性是`undefined`、函数或 XML 对象，该属性会被`JSON.stringify()`过滤。 

   如果数组的成员是`undefined`、函数或 XML 对象，则这些值被转成`null`。 

   正则对象会被转成空对象。 

   `JSON.stringify()`方法会忽略对象的不可遍历的属性。 (就是说，如果一个对象的属性被设置为不可遍历，那么JSON.stringify 就会忽略它)

  ```js
  var obj = {};
  Object.defineProperties(obj, {
    'foo': {
      value: 1,
      enumerable: true
    },
    'bar': {
      value: 2,
      enumerable: false
    }
  });
  
  JSON.stringify(obj); // "{"foo":1}"
  ```

   上面代码中，`bar`是`obj`对象的不可遍历属性，`JSON.stringify`方法会忽略这个属性。 

+  `JSON.stringify()`方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。 

    ```js
    var obj = {
      'prop1': 'value1',
      'prop2': 'value2',
      'prop3': 'value3'
    };

    var selectedProperties = ['prop1', 'prop2'];

    JSON.stringify(obj, selectedProperties)
    // "{"prop1":"value1","prop2":"value2"}"
    ```

    上面代码中，`JSON.stringify()`方法的第二个参数指定，只转`prop1`和`prop2`两个属性。

    这个类似白名单的数组，只对对象的属性有效，对数组无效。

    ```js
    JSON.stringify(['a', 'b'], ['0'])
    // "["a","b"]"

    JSON.stringify({0: 'a', 1: 'b'}, ['0'])
    // "{"0":"a"}"
    ```

    上面代码中，第二个参数指定 JSON 格式只转`0`号属性，实际上对数组是无效的，只对对象有效。

    第二个参数还可以是一个函数，用来更改`JSON.stringify()`的返回值。

     上面代码中的`f`函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以`2`，否则就原样返回。 

     注意，这个处理函数是递归处理所有的键。 

    ```js
    var obj = {a: {b: 1}};

    function f(key, value) {
      console.log("["+ key +"]:" + value);
      return value;
    }

    JSON.stringify(obj, f)
    // []:[object Object]
    // [a]:[object Object]
    // [b]:1
    // '{"a":{"b":1}}'
    ```

    上面代码中，对象`obj`一共会被`f`函数处理三次，输出的最后那行是`JSON.stringify()`的默认输出。第一次键名为空，键值是整个对象`obj`；第二次键名为`a`，键值是`{b: 1}`；第三次键名为`b`，键值为1。

    递归处理中，每一次处理的对象，都是前一次返回的值。

    ```js
    var obj = {a: 1};

    function f(key, value) {
      if (typeof value === 'object') {
        return {b: 2};
      }
      return value * 2;
    }

    JSON.stringify(obj, f)
    // "{"b": 4}"
    ```

     如果处理函数返回`undefined`或没有返回值，则该属性会被忽略。 

    ```js
    function f(key, value) {
      if (typeof(value) === "string") {
        return undefined;
      }
      return value;
    }

    JSON.stringify({ a: "abc", b: 123 }, f)
    // '{"b": 123}'
    ```

     上面代码中，`a`属性经过处理后，返回`undefined`，于是该属性被忽略了。 

+ `JSON.stringify()`还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。 

     默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）。 

    ```js
    // 默认输出
    JSON.stringify({ p1: 1, p2: 2 })
    // JSON.stringify({ p1: 1, p2: 2 })
    
    // 分行输出
    JSON.stringify({ p1: 1, p2: 2 }, null, '\t')
    // {
    // 	"p1": 1,
    // 	"p2": 2
    // }
    ```

    上面例子中，第三个属性`\t`在每个属性前面添加一个制表符，然后分行显示。

    第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）。

### 参数对象的 toJSON() 方法

如果参数对象有自定义的`toJSON()`方法，那么`JSON.stringify()`会使用这个方法的返回值作为参数，而忽略原对象的其他属性。

下面是一个普通的对象。